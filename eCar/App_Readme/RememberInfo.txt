///////////////////////////////////////////////////////////////////////////////
<elmah>-------------------------------------------------------------------------
порядок действий совершенных мною по внедрению elmah:
1. Установка elmah с помощью менеджера пакетов NuGet.
2. Редактирование Web.config: добавление деталей безопасности, уведомлений ошибок и фильтров по использованию elmah.
3. Создание собственного обработчика ошибок ElmahHandleErrorAttribute.cs
4. Его регистрация в global.asax.
5. filters.Add(new ElmahHandleErrorAttribute())
6. Добавляем возможность логировать ошибки javascript:
			- создаем класс JavaScriptException;
			- добавляем ErrorController;
			- реализуем трассировку стека JavaScript(добавляем готовый файл errorhandler.js)
			- добаляем следующие скрипты на главную страницу
			<script type="text/javascript">
				var logErrorUrl = '@Url.Action("LogJavaScriptError", "Error")';
			</script>
			<script src="@Url.Content("~/Scripts/errorhandler.js")" type="text/javascript"></script>
/////////////////////////////////////////////////////////////////////////////////////////
<quartz>----------------------------------------------------------------------------------
Сначала для простоты был создан простый планировщик, который просто выводил сообщение в окно "Вывод".
Последовательность моих действий:
1.Установка quartz (NuGet)
2.Создаем клас Beckup
	public class Beckup:IJob
	{
		public void Execute(IJobExecutionContext context)
		{
			Debug.WriteLine("Hello at " + DateTime.Now.ToString());
		}
	}
3.В Global.asax создаем статический метод ConfigureQuartzJobs:
		public static void ConfigureQuartzJobs()
        {
            // construct a scheduler factory
            ISchedulerFactory schedFact = new StdSchedulerFactory();

            // get a scheduler
            IScheduler sched = schedFact.GetScheduler();
            sched.Start();

            // construct job info
            IJobDetail jobDetail = new JobDetailImpl("myJob", null, typeof(Beckup));

            SimpleTriggerImpl trigger=new SimpleTriggerImpl("myTrigger",10,TimeSpan.FromSeconds(20));

            sched.ScheduleJob(jobDetail, trigger);
        }
4. Вызывае его в Application_Start.

5. Позже SimpleTriggerImpl был заменен на крон-треггер вида:

	ITrigger trigger = new CronTriggerImpl("myTrigger", null, "0/20 * * * * ?");
6. 

////////////////////////////////////////////////////////////////////////////////////////
<PayPal>----------------------------------------------------------------------------------
Схема оплаты в PayPal выбрана согласно книги М.Белиньясо и его сайта TheBeerHouse.
Причина - простота режима _xclick, а также больше подходит с точки зрения интеграции с структурой оформления заказов 
eCar. Перед мной стоял выбор еще 2 схем : _сart (книга Beggining e-commerce in ASP.NET from novice to proffesional - phase 1) и Order PipeLine 
(книга Beggining e-commerce in ASP.NET from novice to proffesional - phase 3).
В первой схеме режим _сart немножно не подходит под структуру eCar, a Order PipeLine слишком сложний для реализации.
------------------------------------------------------------------------------------------------------------------------
Первоя, что я зделал, так это добавил приватный метод private  GetPayPalPaymentUrl(Order order) в контроллер Checkout. Он как раз и строит преславутую сдтроку
запроса к PayPal,c параметрами, которые описаны в документации PayPal.Самые главные из них : cmd - режим использования страниц PayPal, business - учетная запись в
PayPal, которая будет получателем транзакций, item_number - строка, идентифицирующая заказ, item_name - описательная строка для заказа, которую собирается оплатить
клиент.
Далее добавил еще 3 МД - Complete, Cancel and Notify. Сюда будет перенаправлятся пользователь в зависимости от успешности проведенных операций (опять же эти адреса
зашиты в методе GetPayPalPaymentUrl).По ходу выполнения заказа постоянно обновляется у них статус заказа.
Особого внимания стоит МД Notify. Он использует метод IsVerifiedNotification, в котором посылается специальный запрос на PayPal с целью получения IPN уведомления, 
которое подтверждает действительную покупку, а не фиктивную, подделаную злоумишлениками.
Таким образом, если запрос верифицирован, ....<пропал свет>

В связи с тем, что не получилось должным образом провести транзакцию и чекаут процес на sandbox, возникла потребность в детальном изучении и последующем описании
механизма тестирования транзакций в песочнице.
Поэтому, последовательность действий (пароли возможно будут дублироваться как в моем дневнике логов office-time)
1.Входим в developer.paypal.com под учетной записью dima-fiyalo@bk.ru (vika1103)
2.Видим, что у меня есть как минимум 2 тестовых аккаунта
      -p1510@bk.ru->personal 
	  -bussiness1510@bk.ru->merchant (для обоих пароль входа hello0104)
3.Merchant аккаунт должен быть зарегистрирован на eCar как бизнесс аккаунт (учетная запись в PayPal, которая будет получателем транзакций)
4.Теперь виполняем оформление заказа в eCar. МД AddressAndPayment перенаправит нас на сайт PayPal, там нам нужно будет залогинится как покупатель(p1510@bk.ru->personal)
5.В итоге PayPal перенаправит нас на МД Complete (естественно, после удачного завершения транзакции)
6.Из p1510@bk.ru в bussiness1510@bk.ru будет переведена сума, указана в параметре ammount.
7.Остается открытым вопрос вызова МД Notify()????????????????????????????????????
/////////////////////////////////////////////////////////////////////////////////////////////
<AntiXss>-----------------------------------------------------------------------------------
Защита от атак XSS предполагает кодирование всех опасных символов. И хотя по умолчанию Razor кодирует все, все равно есть проблемы (особенно с кодом, который использует
JavaScript). Так для демонстрации этого был создан експериментальный метод действия AntiXss. Если его вызвать вот так:
http://localhost:1337/Home/AntiXss?UserName=Jon\x3cscript\x3e%20alert(\x27pwnd\x27)%20\x3c/script\x3e
то результат на лицо. Даная уязвимость может решится, если установить библиотеку AntiXssLibrary. Она позволяет кодировать строки, которые используются скриптами.
Сначала я попытался установить кодировщик AntiXss по умолчанию:
...
  <system.web>
    <httpRuntime encoderType="AntiXssEncoder, AntiXssLibrary"/>
...
Но у меня в библиотеке нет типа AntiXssEncoder, а имеющийся тип Encoder не подходит (он не расширяет класс 'System.Web.Util.HttpEncode').
Поэтому пришлось кодировать вручную с помощью Ajax.JavaScriptStringEncode или Encoder.JavaScriptEncode
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<CSRF>----------------------------------------------------------------------------------------------------------------------------------------------------
Защита от CSRF атак осуществляется путем добавления в форму представления хелпера @Html.AntiForgeryToken
Метод Html.AntiForgeryToken создает скрытое поле с уникальным значением:
<input type="hidden" value="012837udny31w90hjhf7u">
Данное значение будет совпадать с другим значением, сохраненным в куках сессии браузера. 
При отправке формы эти значения сопоставляются с помощью фильтра ActionFilter:
[ValidateAntiforgeryToken]
public ActionResult Register(…)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Защита от оверпостинга. Вопще то такая угроза как оверпостинг возникает, когда хитрый пользователь, пользуясь 
таким средством mvc как автоматическая привязка будет пытатся изменить свойства сущностей, добавляя в строку запроса дополнительные
свойства, которых нет на форме отправки. 
На сайте защита реализовалась через атрибут [Bind(Exclude="property1, property2, ...")] на сущностях, которые могут обновлятся через заполнение данных формы.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Защита от атак открытой переадресации. Как описано в книге Professional ASP.NET MVC 3.O (Джон Галловей), сайты mvc 1.0 и mvc 2.0 подвержеоны атакам отркрытой
переадресации. Но на eCar уже имеется встроенный код в методе Account/LogOn/, где параметр returnUrl проверяется на предмет изменений (метод IsLocalUrl).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<Cloud computing throught SharpBox API>----------------------------------------------------------------------------------------------------------------------
Для работы с облачным хранилищем используется библиотека SharpBox API (обезпечивает абстрактный доступ к некотрым облачным сервисам хранения информации - 
DropBox, Box.net, StoreGate и другие).
Первое, что нужно сделать, так это через менеджер пакетов NuGet устанвить библиотеку необходимой версии в приложение(AppLimit.CloudComputing.SarpBox)
(в NBlog это версия 1.0.2, в SharpBox tutorial это 1.1.2)
Далее в интерфейс IServices добавляем поле ICloudService Cloud { get; } и сразу копируем с NBlog CloudService(описания присутствуют, единственное, что нужно сделать,
так это проследить соответсвие версий.) После изменяем Services.cs &  NinjectDependencyResolver.cs
Добавляем в MyConfig.cs новый раздел конфигурации с необходимыми свойствами.

Сначала я попытался установить SharpBox версии 1.2.0 , но поскольку в новой версии не было такого интерфейса, как ICloudeStorageCredentials, это мне существенно 
усложнило жизнь. Поэтому я просто подключил библиотеки SharpBox 1.0.2 из NBlog.
Далее я зарегистрировал приложение eCar на dropbox.com/developers/ и получил App Key и App Secret, сохранил их в web.config(опасно!!!!!!!)
Попытку выполнения копирования файлов в облачное хранилище демонстрирует мд Home/MakeArchive/,
но пока не получается..
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<Autofac>----------------------------------------------------------------------------------------------------------------------------------------------------
В связи с тем, что много серйозных Open Source проектов используют Autofac в качестве контейнера инверсии управления, я решил перейти с Ninject на Autofac.
Для возврата к Ninject в будущем потребуется установить библиотеку через NuGet, включить в проект файл Application/Infrastracture/NinjectDependencyResolver.cs и
в App_Start() использовать код DependencyResolver.SetResolver(new NinjectDependencyResolver());

-------------------------------------------------------------------------------------------------------------------------------------------------------------
<Entity Framework Fluent API>/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Как вскорее стало известно, конфигурация EF Fluent API лучше подойдет к eCar, чем Data Annotation (плюсы: освобождаются от атрибутов классы домена, некоторые
дополнительные возможности). Поэтому переходим на Fluent API(на примере сущности Auto):
1.Создаем класс AutoConfiguration, наследуемый от EntityTypeConfiguration<Auto>, в нем каждый атрибут, который удалится из сущности Auto, должен быть в 
конструкторе сконфигурирован, например Property(d => d.Description).HasMaxLength(500)
2.В класс ECarContext добавляем перегруженый метод OnModelCreating.
3.В этот метод добавляем создание конфигурационного класса AutoConfiguration
4.Пока что замена всех Data Annotation атрибутов на Fluent API приостановлена изза недостаточних знаний в этой области.(возможно потребуется перейти на более 
познюю версию Entity Framework,из 4.1 например на 5.0 или на 6.0)
-------------------------------------------------------------------------------------------------------------------------------------------------------------
<Caching, performance & load tests>///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Для того, чтобы создавать нагрузочные тести и должным образом тестировать сайт на производительность, пришлось перейти из Sql Server Compact на
Sql Server Express. Для этого я просто изменил строку подключения из 
<add name="ECarContext" connectionString="Data Source=|DataDirectory|MvcCarStore.sdf" providerName="System.Data.SqlServerCe.4.0" />
на
<add name="ECarContext" providerName="System.Data.SqlClient" connectionString="Data source=.\SQLEXPRESS;Initial Catalog=ECarDb;Integrated Security=SSPI;User 
Instance=true;AttachDBFilename=|DataDirectory|eData.mdf;MultipleActiveResultSets=True"/>
Всё остальное за меня сделал Code First.

Несмотря на замену, все таки нагрузочные тесты должным образом запустить не получилось. Поэтому пока работа в этом направлении приостановлена.

На сайте реализована техника кеширования вывода (с использованием атрибута [OutputCache]), а также техника разделения запросов с последующей сборкой частей стра-
ницы на клиенте (с помощью ajax метода $('#id').load()). Таким образом информация корзины покупок загружается отдельно.
Широко применяется профилирование кэша. Так  [OutputCache(CacheProfile="HomePageCacheProfile")]
будет настраиватся в файле web.config

<caching>
<outputCacheSettings>
    <outputCacheProfiles>
        <add name="HomePageCacheProfile" duration="3600" varyByParam="none"/>
    </outputCacheProfiles>
</outputCacheSettings>
</caching>

--------------------------------------------------------------------------------------------------------------------------------------------------------------